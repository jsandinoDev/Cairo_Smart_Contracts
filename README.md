# Cairo_Smart_Contracts
Learning Cairo Smart Contracts


- Smart contracts can modify and read the storage of the underlying blockchain. 
- A smart contract has its own address and is considered a blockchain account, meaning it can hold tokens.

-  On Ethereum and the EVM-compatible ecosystem, the most commonly used language is Solidity, while on Starknet, it is Cairo.
-  On Ethereum, Solidity is compiled into bytecode. On Starknet, Cairo is compiled into Sierra and then into Cairo Assembly (CASM).
-  

### Characteristics

- permissionless -> meaning anyone can deploy a smart contract on the network 
- transparent -> he data stored by the smart contract is accessible to anyone
- composability -> allows developers to write smart contracts that use other smart contracts


## Anatomy of a Simple Contract

```
#[starknet::interface]
trait ISimpleStorage<TContractState> {
    fn set(ref self: TContractState, x: u128);
    fn get(self: @TContractState) -> u128;
}

#[starknet::contract]
mod SimpleStorage {
    #[storage]
    struct Storage {
        stored_data: u128
    }

    #[abi(embed_v0)]
    impl SimpleStorage of super::ISimpleStorage<ContractState> {
        fn set(ref self: ContractState, x: u128) {
            self.stored_data.write(x);
        }

        fn get(self: @ContractState) -> u128 {
            self.stored_data.read()
        }
    }
}
```


#### The Interface: the Contract's Blueprint

"#[starknet::interface]"

```
#[starknet::interface]
trait ISimpleStorage<TContractState> {
    fn set(ref self: TContractState, x: u128);
    fn get(self: @TContractState) -> u128;
}
```

- In our interface, note the generic type TContractState of the self argument which is passed by reference to the set function
- The ref modifier implies that self may be modified, meaning that the storage variables of the contract may be modified inside the set function.
- On the other hand, the get function takes a snapshot of TContractState (does not modify the state)

#### Public Funtions

- In the context of Starknet, a public function is a function that is exposed to the outside world. A public function can be called by anyone, either from outside the contract or from within the contract itself. In the example above, set and get are public functions.
- What we call an external function is a public function that can be directly invoked through a Starknet transaction and that can mutate the state of the contract. set is an external function.
- A view function is a public function that is typically read-only and cannot mutate the state of the contract. However, this limitation is only enforced by the compiler, and not by Starknet itself. We will discuss the implications of this in a later section. get is a view function.
___

- The implementation block must be annotated with the #[abi(embed_v0)] attribute 
- This attribute exposes the functions defined in this implementation to the outside world â€” forget to add it and your functions will not be callable from the outside. 
- All functions defined in a block marked as #[abi(embed_v0)] are consequently public functions.

___

- Because the SimpleStorage contract is defined as a module, we need to access the interface defined in the parent module. We can either bring it to the current scope with the use keyword, or refer to it directly using super.
___

- When writing the implementation of an interface, the self parameter in the trait methods must be of type ContractState.
- . The ContractState type is generated by the compiler, and gives access to the storage variables defined in the Storage struct. 
- ContractState gives us the ability to emit events

#### Accessing and Modifying the Contract's State

- read, which returns the value of a storage variable. This method is called on the variable itself and does not take any argument.
   ```  self.stored_data.read() ```

- write, which allows to write a new value in a storage slot. 
- This method is also called on the variable itself and takes one argument, which is the value to be written. 
- Note that write may take more than one argument, depending on the type of the storage variable. For example, writing on a mapping requires 2 arguments: the key and the value to be written.
    ```  self.stored_data.write(x); ```


Reminder: if the contract state is passed as a snapshot with @ instead of passed by reference with ref, attempting to modify the contract state will result in a compilation error.